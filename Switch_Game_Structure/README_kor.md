# 패킷 분석
## 구조
### 개요
---
Packet을 만들 때 nn::pia::common::Packet에서 packet header를 만들어준다. 
아래는 이에 대한 정보다.
### Class & 구조체
```
/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'acnh'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

/* 804 */
struct __attribute__((aligned(8))) nn::pia::common::Packet::Header::vtable
{
  __int64 nn::pia::lan::LanMessage::refunc_8252ed30;
  __int64 nn::pia::common::Packet::Header::_TILDE_Header;
  __int64 nn::pia::common::Packet::Header::Serialize;
  __int64 nn::pia::common::Packet::Header::Deserialize;
  __int64 nn::pia::common::Packet::Header::GetSerializedSize;
};

/* 806 */
struct __attribute__((aligned(8))) nn::pia::common::Packet::Header
{
  nn::pia::common::Packet::Header::vtable *vtable_;
  int magic_;
  char flag_;
  char padding1[3];
  int destination_variable_id_;
  int source_variable_id_;
  __int16 packet_id_;
  char footer_size_;
  __attribute__((packed)) __attribute__((aligned(1))) __int64 aes_gcm_nonce_;
  __attribute__((packed)) __attribute__((aligned(1))) __int64 aes_gcm_authentication_tag_;
  __attribute__((packed)) __attribute__((aligned(1))) __int64 unknown1;
  __attribute__((aligned(8))) char packet_[1472];
  int packet_size_;
  __attribute__((aligned(8))) int assign_size_;
  int unknown2;
  char nn::pia::common::StationAddress_[40];
  int unknown3;
};
```
## 패킷 송수신
### 개요 
닌텐도 스위치는 IPC를 이용해서 패킷을 주고 받는다.
IPC를 통해 시스템 서비스에게 요청을 보내, 그 시스템 서비스가 대신 패킷을 보내거나 받는다.
### IPC를 사용하는 시스템콜
다음과 같은 세가지 시스템콜이 IPC를 이용한다.
- svc::SendSyncRequest()
- svc::SendSyncRequestWithUserBuffer()
- svc::SendAsyncRequestWithUserBuffer()
분석하면서 지금까지 패킷을 보내고 받을때 svc::SendSyncRequest()가 호출되는 것을 확인했다.
나머지 시스템콜들도 다른 상황에 이용될 수 있을 것이다.
### Message buffer 사용
패킷을 보내기전에 Message buffer에 패킷의 내용을 미리 담는다.
![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2f11a5fa-4e62-4c72-b7e2-a459d91ae122/cffe72f6-01e3-4702-b798-02c0d1cfd073/Untitled.png)
if문을 통화하려면 ARM64_SYSREG(3, 3, 13, 0, 3)이 a2랑 같아야한다.
a2는 thread local storage 위치에 있다. 
즉 thread local storage가 message buffer로 이용된다는 것을 알 수 있다.
![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2f11a5fa-4e62-4c72-b7e2-a459d91ae122/f5f660d8-0e41-4e54-b803-1da471d1c500/Untitled.png)
TPIDR_EL0에서 per-thread structure를 저장한다[1]. 즉 a2가 thread local storage라는 것을 알 수 있다.
if문에 들어가고 SendSyncRequest syscall을 부르면 a2에 있었던 위치에 IPC를 통해 값을 읽고 쓴다.
### 패킷 통신에 사용되는 시스템콜
`svc 0x21 - SendSyncRequest(Handle session_handle)`
서버 또는 peer가 svc 0x ReplyAndReceive()를 실행했다면 Client가 셋팅한 message buffer를 IPC를 통해 서버 또는 peer한테 보낸다.
`svc 0x43 - ReplyAndReceive(int32_t *out_index, const Handle *handles, int32_t num_handles, Handle reply_target, int64_t timeout_ns)`
서버 또는 peer가 client랑 packet을 주고 받을 때 실행한다.
## 패킷 분석하기
### 개요
닌텐도에서 패킷을 주고 받는 패킷을 분석해야할 때가 있다.
이때 닌텐도 와이파이 설정에서 proxy server 설정을 할 수 있다. 
여기서 본인이 구축한 proxy server로 설정하면 패킷은 해당 서버로 패킷을 보내게 된다.
이 때 본인이 구축한 proxy server가 cli 환경만 제공한다면 GUI를 사용하는 wireshark를 쓰기 힘들다. 
그렇기 때문에 CLI 환경에서 작동하는 tshark를 사용하면 된다.
### T-shark 사용
```
apt install tshark
```
위 명령을 통해 tshark를 설치할 수 있다.
```
tshark -D
```
위에 명령어를 실행해서 내가 볼 NIC의 숫자를 기억한다
이제 다음과 같은 옵션을 넣어서 패킷을 캡쳐할 수 있다
```
tshark -i 3 -Y 'tcp.port == 80 && ip.addr == 192.168.1.10' -t a --color
```
`-i` : NIC의 숫자
`-Y` : 필터 옵션
`-t` : 시간 옵션
`—color` : 색 옵션
위에 명령어를 실행하면 /tmp에 .pcapng 파일이 생긴다.
