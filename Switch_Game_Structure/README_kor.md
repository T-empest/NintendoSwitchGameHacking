# 패킷 분석
## 구조
### 개요
Packet을 만들 때 nn::pia::common::Packet에서 packet header를 만들어준다. 
아래는 이에 대한 정보다.
### Class & 구조체
```
/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'acnh'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

/* 804 */
struct __attribute__((aligned(8))) nn::pia::common::Packet::Header::vtable
{
  __int64 nn::pia::lan::LanMessage::refunc_8252ed30;
  __int64 nn::pia::common::Packet::Header::_TILDE_Header;
  __int64 nn::pia::common::Packet::Header::Serialize;
  __int64 nn::pia::common::Packet::Header::Deserialize;
  __int64 nn::pia::common::Packet::Header::GetSerializedSize;
};

/* 806 */
struct __attribute__((aligned(8))) nn::pia::common::Packet::Header
{
  nn::pia::common::Packet::Header::vtable *vtable_;
  int magic_;
  char flag_;
  char padding1[3];
  int destination_variable_id_;
  int source_variable_id_;
  __int16 packet_id_;
  char footer_size_;
  __attribute__((packed)) __attribute__((aligned(1))) __int64 aes_gcm_nonce_;
  __attribute__((packed)) __attribute__((aligned(1))) __int64 aes_gcm_authentication_tag_;
  __attribute__((packed)) __attribute__((aligned(1))) __int64 unknown1;
  __attribute__((aligned(8))) char packet_[1472];
  int packet_size_;
  __attribute__((aligned(8))) int assign_size_;
  int unknown2;
  char nn::pia::common::StationAddress_[40];
  int unknown3;
};
```
## 패킷 송수신
### 개요 
닌텐도 스위치는 IPC를 이용해서 패킷을 주고 받는다.
IPC를 통해 시스템 서비스에게 요청을 보내, 그 시스템 서비스가 대신 패킷을 보내거나 받는다.
### IPC를 사용하는 시스템콜
다음과 같은 세가지 시스템콜이 IPC를 이용한다.
- svc::SendSyncRequest()
- svc::SendSyncRequestWithUserBuffer()
- svc::SendAsyncRequestWithUserBuffer()
분석하면서 지금까지 패킷을 보내고 받을때 svc::SendSyncRequest()가 호출되는 것을 확인했다.
나머지 시스템콜들도 다른 상황에 이용될 수 있을 것이다.
### Message buffer 사용
--- 
패킷을 보내기전에 Message buffer에 패킷의 내용을 미리 담는다.
[사진1]
if문을 통화하려면 ARM64_SYSREG(3, 3, 13, 0, 3)이 a2랑 같아야한다.
a2는 thread local storage 위치에 있다. 
즉 thread local storage가 message buffer로 이용된다는 것을 알 수 있다.
[사진2]
TPIDR_EL0에서 per-thread structure를 저장한다[1]. 즉 a2가 thread local storage라는 것을 알 수 있다.
if문에 들어가고 SendSyncRequest syscall을 부르면 a2에 있었던 위치에 IPC를 통해 값을 읽고 쓴다.
### 패킷 통신에 사용되는 시스템콜
`svc 0x21 - SendSyncRequest(Handle session_handle)`
서버 또는 peer가 svc 0x ReplyAndReceive()를 실행했다면 Client가 셋팅한 message buffer를 IPC를 통해 서버 또는 peer한테 보낸다.
`svc 0x43 - ReplyAndReceive(int32_t *out_index, const Handle *handles, int32_t num_handles, Handle reply_target, int64_t timeout_ns)`
서버 또는 peer가 client랑 packet을 주고 받을 때 실행한다.
## 패킷 분석하기
### 개요
닌텐도에서 패킷을 주고 받는 패킷을 분석해야할 때가 있다.
이때 닌텐도 와이파이 설정에서 proxy server 설정을 할 수 있다. 
여기서 본인이 구축한 proxy server로 설정하면 패킷은 해당 서버로 패킷을 보내게 된다.
이 때 본인이 구축한 proxy server가 cli 환경만 제공한다면 GUI를 사용하는 wireshark를 쓰기 힘들다. 
그렇기 때문에 CLI 환경에서 작동하는 tshark를 사용하면 된다.
### T-shark 사용
```
apt install tshark
```
위 명령을 통해 tshark를 설치할 수 있다.
```
tshark -D
```
위에 명령어를 실행해서 내가 볼 NIC의 숫자를 기억한다
이제 다음과 같은 옵션을 넣어서 패킷을 캡쳐할 수 있다
```
tshark -i 3 -Y 'tcp.port == 80 && ip.addr == 192.168.1.10' -t a --color
```
`-i` : NIC의 숫자
`-Y` : 필터 옵션
`-t` : 시간 옵션
`—color` : 색 옵션
위에 명령어를 실행하면 /tmp에 .pcapng 파일이 생긴다.
# JPEG 분석
## JPEGMGR thread 분석
### 개요 
JPEG 파싱을 담당하는 쓰레드가 존재한다.
그 쓰레드에 대한 분석을 진행하였다.
### 구조
[구조 사진]
### 분석
직접 JPEGMGR Thread를 분석해보면서 스위치 게임을 쓰레드들의 구조에 대해서 알 수 있다.
`nn::os::detail::ThreadManagerImplByHorizon::CreateThread(nn::os::ThreadType *,void (*)(nn::os::ThreadType *),int)` 을 통해 초반에 Jpeg Mgr 쓰레드가 생성된다.
초반에 tls같은 쓰레드의 로컬 스토리지를 초기화해준다.
분석을 좀 더 수월하게 진행하기 위해서 Bindiff를 이용해서 디핑을 먼저 진행한다.
[디핑 사진]
File→BinDiff를 클릭해서 IDB를 이용해 디핑을 할 수 있다.
그리고 원하는 부분을 클릭해서 symbol을 적용시킬 수 있다.

#### ThreadMain
```
__int64 __fastcall dispatch(__int64 a1)
{
  __int64 v1; // x20
  __int64 result; // x0
  __int64 v4; // x1

  v1 = a1 + 48;
  result = get_msg(a1 + 48, *(_DWORD *)(a1 + 184));
  if ( result != *(_QWORD *)(a1 + 192) )
  {
    v4 = result;
    do
    {
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 136LL))(a1, v4);
      result = get_msg(v1, *(_DWORD *)(a1 + 184));
      v4 = result;
    }
    while ( result != *(_QWORD *)(a1 + 0xC0) );
  }
  return result;
}
```
이런식의 구조를 취하고 있다.
get_msg는 nn::os::TryReceiveMessageQueue를 이용해 메세지 큐에서 메세지를 pop한다.
이후 여기서 세팅된 구조체에 따라 동작이 달라진다.
#### TryReceiveMessageQueue
```
__int64 __fastcall nn::os::TryReceiveMessageQueue(_QWORD *ptr, __int64 object_0x30)
{
  nn::os::detail::InternalCriticalSectionImplByHorizon *v2; // x19
  int v5; // w8
  __int64 v6; // x10
  int v7; // w8
  int v8; // w9
  __int64 msgs; // x11
  int v10; // w10
  __int64 i; // x21

  v2 = (nn::os::detail::InternalCriticalSectionImplByHorizon *)(object_0x30 + 0x38);
  nn::os::detail::InternalCriticalSectionImplByHorizon::Enter((nn::os::detail::InternalCriticalSectionImplByHorizon *)(object_0x30 + 0x38));
  v5 = *(_DWORD *)(object_0x30 + 0x2C);
  if ( v5 )
  {
    v6 = *(int *)(object_0x30 + 0x30);
    v7 = v5 - 1;
    v8 = *(_DWORD *)(object_0x30 + 0x28);
    msgs = *(_QWORD *)(*(_QWORD *)(object_0x30 + 0x20) + 8 * v6);// *(object + 0x40) <= msg array?
    v10 = v6 + 1;                               // initializing?
    if ( v10 < v8 )
      v8 = 0;
    *(_DWORD *)(object_0x30 + 0x2C) = v7;
    *(_DWORD *)(object_0x30 + 0x30) = v10 - v8;
    *ptr = msgs;                                // SignalProcessWideKey 0x1d syscall
    nn::os::detail::InternalConditionVariableImplByHorizon::Broadcast((nn::os::detail::InternalConditionVariableImplByHorizon *)(object_0x30 + 0x3C));
    for ( i = *(_QWORD *)(object_0x30 + 8); i != object_0x30; i = *(_QWORD *)(i + 8) )
      nn::os::detail::MultiWaitImpl::NotifyAndWakeupThread(
        *(nn::os::detail::MultiWaitImpl **)(i + 16),
        (nn::os::detail::MultiWaitHolderBase *)(i - 24));
    nn::os::detail::InternalCriticalSectionImplByHorizon::Leave(v2);
    return 1LL;
  }
  else
  {
    nn::os::detail::InternalCriticalSectionImplByHorizon::Leave(v2);
    return 0LL;
  }
}
```

