# 패킷 분석
## 구조
### 개요
Packet을 만들 때 nn::pia::common::Packet에서 packet header를 만들어준다. 
아래는 이에 대한 정보다.
### Class & 구조체
```
/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'acnh'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

/* 804 */
struct __attribute__((aligned(8))) nn::pia::common::Packet::Header::vtable
{
  __int64 nn::pia::lan::LanMessage::refunc_8252ed30;
  __int64 nn::pia::common::Packet::Header::_TILDE_Header;
  __int64 nn::pia::common::Packet::Header::Serialize;
  __int64 nn::pia::common::Packet::Header::Deserialize;
  __int64 nn::pia::common::Packet::Header::GetSerializedSize;
};

/* 806 */
struct __attribute__((aligned(8))) nn::pia::common::Packet::Header
{
  nn::pia::common::Packet::Header::vtable *vtable_;
  int magic_;
  char flag_;
  char padding1[3];
  int destination_variable_id_;
  int source_variable_id_;
  __int16 packet_id_;
  char footer_size_;
  __attribute__((packed)) __attribute__((aligned(1))) __int64 aes_gcm_nonce_;
  __attribute__((packed)) __attribute__((aligned(1))) __int64 aes_gcm_authentication_tag_;
  __attribute__((packed)) __attribute__((aligned(1))) __int64 unknown1;
  __attribute__((aligned(8))) char packet_[1472];
  int packet_size_;
  __attribute__((aligned(8))) int assign_size_;
  int unknown2;
  char nn::pia::common::StationAddress_[40];
  int unknown3;
};
```
## 패킷 송수신
### 개요 
닌텐도 스위치는 IPC를 이용해서 패킷을 주고 받는다.
IPC를 통해 시스템 서비스에게 요청을 보내, 그 시스템 서비스가 대신 패킷을 보내거나 받는다.
### IPC를 사용하는 시스템콜
다음과 같은 세가지 시스템콜이 IPC를 이용한다.
- svc::SendSyncRequest()
- svc::SendSyncRequestWithUserBuffer()
- svc::SendAsyncRequestWithUserBuffer()
분석하면서 지금까지 패킷을 보내고 받을때 svc::SendSyncRequest()가 호출되는 것을 확인했다.
나머지 시스템콜들도 다른 상황에 이용될 수 있을 것이다.
### Message buffer 사용
--- 
패킷을 보내기전에 Message buffer에 패킷의 내용을 미리 담는다.

![img](./img/1.png)

if문을 통화하려면 ARM64_SYSREG(3, 3, 13, 0, 3)이 a2랑 같아야한다.
a2는 thread local storage 위치에 있다. 
즉 thread local storage가 message buffer로 이용된다는 것을 알 수 있다.

![img2](./img/2.png)

TPIDR_EL0에서 per-thread structure를 저장한다[1]. 즉 a2가 thread local storage라는 것을 알 수 있다.
if문에 들어가고 SendSyncRequest syscall을 부르면 a2에 있었던 위치에 IPC를 통해 값을 읽고 쓴다.
### 패킷 통신에 사용되는 시스템콜
`svc 0x21 - SendSyncRequest(Handle session_handle)`
서버 또는 peer가 svc 0x ReplyAndReceive()를 실행했다면 Client가 셋팅한 message buffer를 IPC를 통해 서버 또는 peer한테 보낸다.
`svc 0x43 - ReplyAndReceive(int32_t *out_index, const Handle *handles, int32_t num_handles, Handle reply_target, int64_t timeout_ns)`
서버 또는 peer가 client랑 packet을 주고 받을 때 실행한다.
## 패킷 분석하기
### 개요
닌텐도에서 패킷을 주고 받는 패킷을 분석해야할 때가 있다.
이때 닌텐도 와이파이 설정에서 proxy server 설정을 할 수 있다. 
여기서 본인이 구축한 proxy server로 설정하면 패킷은 해당 서버로 패킷을 보내게 된다.
이 때 본인이 구축한 proxy server가 cli 환경만 제공한다면 GUI를 사용하는 wireshark를 쓰기 힘들다. 
그렇기 때문에 CLI 환경에서 작동하는 tshark를 사용하면 된다.
### T-shark 사용
```
apt install tshark
```
위 명령을 통해 tshark를 설치할 수 있다.
```
tshark -D
```
위에 명령어를 실행해서 내가 볼 NIC의 숫자를 기억한다
이제 다음과 같은 옵션을 넣어서 패킷을 캡쳐할 수 있다
```
tshark -i 3 -Y 'tcp.port == 80 && ip.addr == 192.168.1.10' -t a --color
```
`-i` : NIC의 숫자
`-Y` : 필터 옵션
`-t` : 시간 옵션
`—color` : 색 옵션
위에 명령어를 실행하면 /tmp에 .pcapng 파일이 생긴다.
## ENL Task Thread 분석
### 개요
아래 모든 분석은 Splatoon2에서 진행했다.
### 패킷 수신
![](./img/3.png){: width="100" height="100"}

실질적으로 ENL 관련 처리하는 쓰레드이다.

```jsx
sead::Thread::run_ → messageQueuepop -> ...
-> enl::TaskThread::calc_ -> enl::PiaFramework::dispatch → *
```

위와 같은 순서로 실행이 되며, 실질적으로 패킷을 처리한다.

```jsx
nn::pia::transport::ProtocolManager::Dispatch 
-> nn::pia::transport::StationProtocol::Dispatch
-> nn::pia::transport::StationProtocol::ParseMsgFromReliable 
-> nn::pia::transport::StationProtocolReliable::Receive
```

예를 들자면, 방에 접속할때는 아래와 같이 처리된다.

```jsx
nn::pia::transport::ConnectStationJob::SendConnectionRequest
-> nn::pia::transport::ConnectStationJob::SendConnectionRequestMessage 
-> nn::pia::transport::StationProtocol::MakeConnectionRequestData 
-> ( nn::pia::transport::StationConnectionInfo::GetSerializedSize = 0x46 sz ) & ( nn::pia::transport::StationConnectionInfo::Serialize) 
-> nn::pia::transport::StationLocation::Serialize (Little <-> Big)
```

### unreliable protocol session search


1-day 분석했던 unreliable protocol도 이 쓰레드에서 처리되었던 프로토콜이다.
다른 쓰레드에서 요청이 들어올때 처리되는 경우가 있다.

```jsx
... -> sead::Thread::run_ -> enl::TaskThread::calc_ 
-> sead::Delegate1R<enl::MatchingManager,void *,enl::Result>::invoke 
-> enl::MatchingManager::callfindMatch -> enl::PiaLocalMatchingManager::findMatch 
->  enl::PiaLocalMatchingManager::matchmake_
```

이때 matchmake 내부에서 호출되는 함수중 enl::PiaLocalMatchingManager::prepareSession_는 세션 초기화를 해주고 enl::PiaLocalMatchingManager::procSessionEvent_가 케이스별로  enl::PiaUtil::JoinSession & enl::PiaUtil::SearchSession & enl::PiaUtil::CreateSession 함수를 호출한다.

이때 세션을 검색하는 부분인데, 그때의 함수 호출은 아래와 같이 이루어진다.

```jsx
enl::PiaUtil::SearchSession -> enl::PiaFramework::dispatch 
-> nn::pia::common::Scheduler::Dispatch -> nn::pia::common::Job::Execute 
-> nn::pia::transport::Transport::DispatchJob::ExecuteCore 
-> nn::pia::transport::Transport::dispatch 
-> nn::pia::transport::ProtocolManager::Dispatch 
-> nn::pia::transport::UnreliableProtocol::Dispatch
```

### Pia class Serialize & Deserialize

```c
_BYTE *__fastcall nn::pia::common::serializeU64(_BYTE *this, unsigned __int8 *a2)
{
  *this = HIBYTE(a2);
  this[1] = BYTE6(a2);
  this[2] = BYTE5(a2);
  this[3] = BYTE4(a2);
  this[4] = BYTE3(a2);
  this[5] = BYTE2(a2);
  this[6] = BYTE1(a2);
  this[7] = (_BYTE)a2;
  return this;
}
unsigned __int64 __fastcall nn::pia::common::deserializeU64(nn::pia::common *this, const unsigned __int8 *a2)
{
  return _byteswap_uint64(*(_QWORD *)this);
}

```

이런식으로 단순 리틀엔디안, 빅엔디안 변환부터 여러가지 직렬화 과정이 존재한다.
